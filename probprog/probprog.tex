% !TEX root = ../main.tex

\chapter{Probabilistic Programming and the Need for Automation}
\label{chp:probprog}

\todo[inline]{Better chapter title}

In this chapter we will provide a high level introduction to probabilistic programming,
outlining its aims and explaining how it can be used for and extend Bayesian modeling.  Our
key points are the ability of probabilistic programming to provide the \emph{flexibility} to define
wide ranging and potentially obscure models, \emph{expressivity} by providing a framework for 
model definition that is more in line we conventional scientific simulation than mainstream 
statistical approaches, and \emph{automation} by decoupling model specification and inference 
using general purpose inference engines that run on any problem the user might write.  
Together these characteristics produce a framework that allows researchers whose expertise 
lies elsewhere, to carry out powerful statistical analyses and deliver the best possible 
performance for their application specific tasks.  It also aids in the development of both inference
algorithms and models for those within the machine learning and statistics communities,
by removing many of the complications of one while developing the other.

We will for now focus on a user's perspective, introducing how and why one might want to use
probabilistic programming, explain how ideas from more mainstream Bayesian
modeling can be transfered, and demonstrate how probabilistic programming can be
used to both extend the traditional Bayesian framework and reinterpret many computational simulation
techniques not usually associated with Bayesian modeling in a more Bayesian mindset.
We will mostly ignore the rather major issue of how to conduct Bayesian inference for
models defined in probabilistic programs, assuming for now that we have magical
general purpose systems, before returning to actually confront this major stumbling
block in Chapter~\ref{chp:proginf} once we have introduced the problems of Bayesian
inference more generally.  We will provide a brief introduction to the Anglican probabilistic
programing system (PPS) to give us a platform for providing examples and highlighting
key components of designing a PPS.  Finally, we discuss some of the current limitations
and opportunities for probabilitistic programming systems (other than the obvious computational
issues we which return to later), in particular demonstrating how we can use them to go beyond
standard inference frameworks and why we would want to do so.

\input{probprog/sim.tex}

\section{Two Distinct Approaches}
\label{sec:probprog:two}

Probabilistic programming systems allow users to define probabilistic models using a domain-specific programming language. A probabilistic program implicitly defines a distribution on random variables, whilst the system back-end implements general-purpose inference methods.  

PPS such as Infer.Net \citep{minka_software_2010} and Stan \citep{carpenter2015stan} can be thought of as defining graphical models or factor graphs.  Our focus will instead be on systems such as Church \citep{goodman_uai_2008}, Venture \citep{mansinghka2014venture}, WebPPL \citep{goodman_book_2014}, and Anglican \citep{wood2014new}, which employ a general-purpose programming language for model specification. In these systems, the set of random variables is dynamically typed, such that it is possible to write programs in which this set differs from execution to execution.  This allows an unspecified number of random variables and incorporation of arbitrary black box deterministic functions, such as was exploited by the \simulatec function in Figure \ref{fig:house-heating-code}. The price for this expressivity is that inference methods must be formulated in such a manner that they are applicable to models where the density function is intractable and can only be evaluated during forwards simulation of the program. 


\section{An Introduction to Anglican}
\label{sec:probprog:anglican}

One such general purpose system, \emph{Anglican}, will be used as a reference in this paper.  In Anglican, models are defined using the inference macro \defquery. These models, which we refer to as queries \citep{goodman_uai_2008}, specify a joint distribution $p(Y,X)$ over data $Y$ and variables $X$. Inference on the model is performed using the macro \doquery, which produces a sequence of approximate samples from the conditional distribution $p(X|Y)$ and, for importance sampling based inference algorithms (e.g. sequential Monte Carlo), a marginal likelihood estimate $p(Y)$.  

Random variables in an Anglican program are specified using \sample statements, which can be thought of as terms in the prior. Conditioning is specified using \observe statements which can be thought of as likelihood terms.  Outputs of the program, taking the form of posterior samples, are indicated by the return values.  There is a finite set of \sample and \observe statements in a program source code, but the number of times each statement is called can vary between executions.  We refer the reader to  \href{http://www.robots.ox.ac.uk/~fwood/anglican/}{\small\url{http://www.robots.ox.ac.uk/~fwood/anglican/}} for more details.

\section{Bayesian Models as Program Code}
\label{sec:probprog:models}


Ability to use implicit measure without defining them.


\section{Going Beyond Bayesian Inference}
\label{sec:probprog:limit}
