% !TEX root = ../main.tex

\chapter{Probabilistic Programming -- the User's Perspective}
\label{chp:probprog}

Probabilistic programming systems (PPSs) allow probabilistic models to be represented in the 
form of a generative model and statements for conditioning on data~\citep{gordon2014probabilistic,goodman2008church}.  
Informally, one can think of the generative model as the definition of a prior, the conditioning 
statements as the definition of a likelihood, and the output of the program as samples from a posterior distribution. 
Their core philosophy is to decouple model specification and inference, the former 
corresponding to the user-specified program code, which implicitly 
defines a distribution on random variables, and the latter to an inference engine 
capable of operating on arbitrary programs.  Removing the need for users to write 
inference algorithms significantly reduces the burden of developing new models and 
makes effective statistical methods accessible to non-experts.  The inference/model abstraction barrier 
further means that some systems allow the definition of models that would be hard, or
even impossible, to convey using conventional frameworks like graphical models.


%Probabilistic programming systems (PPSs) allow users to define probabilistic models 
%using a domain-specific programming language or modeling library. A probabilistic program implicitly 
%defines a distribution on random variables, whilst the system back-end implements 
%general-purpose inference methods.  
Two key challenges for PPS are providing the
syntax and semantics to allow easy definition of models, and in designing the solvers, i.e.
inference engines, to provide effective inference for those models.
In this chapter, we focus on the former of these, providing an introduction to 
probabilistic programming from a user's perspective.  We will outline how it can be used for, and
to extend, conventional Bayesian modeling and how it can also be used to reinterpret many computational simulation
techniques not usually associated with Bayesian modeling in a more Bayesian mindset.
We will mostly ignore the rather major issue of how to construct inference engines for PPS, returning to address this in Chapter~\ref{chp:proginf}.
Instead, we will focus on how general purpose PPSs aim to  provide 
the \emph{flexibility} to define
wide-ranging and potentially obscure models, the \emph{expressivity} of a framework for 
model definition that is more in line with conventional scientific simulation than mainstream 
statistical approaches, and the \emph{automation} to  run any problem the user might write
by decoupling model specification and inference.
Together these characteristics produce a framework that allows researchers whose expertise 
lies elsewhere, to carry out powerful statistical analyses for their application specific tasks.  
This framework also aids in the development of both inference
algorithms and models for those within the machine learning and statistics communities,
by removing many of the complications of one while developing the other.
%
%We will for now focus on a user's perspective, introducing how and why one might want to use
%probabilistic programming, explain how ideas from more mainstream Bayesian
%modeling can be transferred, and demonstrate how probabilistic programming can be
%used to both extend the traditional Bayesian framework and reinterpret many computational simulation
%techniques not usually associated with Bayesian modeling in a more Bayesian mindset.
%We will mostly ignore the rather major issue of how to conduct Bayesian inference for
%models defined in probabilistic programs, assuming for now that we have a magical
%general purpose inference engine that will solve any model we provide,
%before returning to actually confront this major stumbling
%block in Chapter~\ref{chp:proginf} once we have introduced the problems of Bayesian
%inference more generally.  We will provide a brief introduction to the Anglican PPS
%to give us a platform for providing examples and highlighting
%key components of designing a PPS.  Finally, we discuss some of the current limitations
%and opportunities for PPSs (other than the obvious computational
%issues which we return to later), in particular demonstrating how we can use them to go beyond
%standard inference frameworks and why we would want to do so.

We note that it will be necessary at times during this chapter to refer briefly to some Bayesian inference
algorithms that will not be properly introduced until Chapters~\ref{chp:inf} and~\ref{chp:part}.  
We have situated this chapter before those partly in order to emphasize the point that one should not 
need an intricate knowledge of inference methods to \emph{use} PPSs.  Though it is difficult
to introduce PPSs while completely omitting reference to inference methods, readers who
are not familiar with them should be able to safely ignore which methods are referred to
at a first pass, noting only that different inference algorithms have different requirements and sets 
of problems they perform well on, and thus that the design of a PPS is often intricately linked to the inference
method(s) used.

\input{probprog/sim.tex}
\input{probprog/two.tex}
\input{probprog/models.tex}
\input{probprog/anglican.tex}

%
%\section{Going Beyond Bayesian Inference}
%\label{sec:probprog:limit}
%
%\todo[inline]{Memoization?}